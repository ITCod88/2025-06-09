-- DAY 3 --

-- 숫자 데이터 함수

-- ABS() : 절대값 표현
SELECT ABS(10), ABS(-10)
FROM DUAL;

-- MOD() : 주어진 컬럼이나 값을 나눈 나머지를 반환
SELECT MOD(10, 3), MOD(10, 6), (10/6)
FROM DUAL;

-- CEIL() : 소수점 첫째 자리에서 올림
-- FLOOR() : 소수점 이하 숫자를 버림
SELECT CEIL(123.456), CEIL(123.678), CEIL(123),
       FLOOR(123.456), FLOOR(123.678), FLOOR(123)
FROM DUAL;

-- TRUNC() : 지정한 위치에서부터 버림, 기본값은 0이다. **자주 쓰이는 함수
SELECT TRUNC(123.456, 0),
       TRUNC(123.456, 1),
       TRUNC(123.456, 2),
       TRUNC(123.456, -2)
FROM DUAL;


-- EMPLOYEE 테이블에서
-- 입사한 달이 홀수 달인 사원들의
-- 사번, 사원명, 입사일 조회
SELECT EMP_ID, EMP_NAME, HIRE_DATE
FROM EMPLOYEE
WHERE MOD(SUBSTR(HIRE_DATE, 5, 1), 2) = 1;

-- Oracle은 어느정도 형변환을 해준다. 그래서 위와 같이 문자인데도 숫자취급하여 나눌 수가 있다.


-- MONTHS_BETWEEN() : 두 날짜 사이의 개월 수
SELECT EMP_NAME, HIRE_DATE,
       TRUNC(MONTHS_BETWEEN(SYSDATE, HIRE_DATE))
FROM EMPLOYEE;


-- NEXT_DAY()
-- 앞으로 다가올 가장 가까운 요일을 반환
-- 1:일요일 ~ 7:토요일
SELECT NEXT_DAY(SYSDATE, '토요일'),
	   NEXT_DAY(SYSDATE, '일'),
	   NEXT_DAY(SYSDATE, 6)
	   -- NEXT_DAY(SYSDATE, 'SATURDAY') 영어는 불가능
	   -- 언어설정이 한국어로 되어있기 때문이다.
FROM DUAL;

-- 현재 설정된 정보를 테이블 형태로 보관 -> 이러한 테이블을 '데이터 사전(데이터딕셔너리)'
SELECT * FROM V$NLS_PARAMETERS;

-- LAST_DAY() : 마지막 일(DAY)을 조회
SELECT LAST_DAY(SYSDATE)
FROM DUAL;

-- 날짜값 끼리 +,- 연산 가능
SELECT (SYSDATE - 10),
	   (SYSDATE - TO_DATE('2022/03/01', 'RR/MM/DD')),
	   (SYSDATE + 30)
FROM DUAL;

SELECT HIRE_DATE, (HIRE_DATE + 10)
FROM EMPLOYEE;


--
SELECT SYSDATE,
	   TO_CHAR(SYSDATE, 'RR/MM/DD'),
	   TO_CHAR(SYSDATE, 'YYYY-MM-DD HH:MI:SS'),
	   TO_CHAR(SYSDATE, 'YEAR, Q')|| '분기',
	   TO_CHAR(SYSDATE, 'MON, YYYY')
FROM DUAL;

-- 연도
-- Y/R
SELECT TO_CHAR(TO_DATE('190325', 'YYMMDD'), 'YYYY') "결과1",
	   TO_CHAR(TO_DATE('190325', 'RRMMDD'), 'RRRR') "결과2",
	   TO_CHAR(TO_DATE('800325', 'YYMMDD'), 'YYYY') "결과3",
	   TO_CHAR(TO_DATE('800325', 'RRMMDD'), 'RRRR') "결과4"
FROM DUAL;

-- 4자리 한번에 입력 받는 경우는 문제X
-- 2자리 입력 받을 경우
-- YY => 현 세기 기준으로 값을 추가
-- RR => 반 세기 


-- RR 
-- 50~99 -> 1900년대
-- 00~49 -> 2000년대

-- YY
-- 80 -> 2080


-- SELECT 문의 실행 순서
/*
-- 5: SELECT 컬럼 AS 별칭, 계산식, 함수
-- 1: FROM 테이블명
-- 2: WHERE 조건
-- 3: GROUP BY 그룹을 묶을 컬럼명
-- 4: HAVING 그룹에 대한 조건식, 함수식
-- 6: ORDER BY 컬럼|별칭|순서 [ASC/DESC][, 컬럼명...]
*/


-- ORDER BY --
SELECT EMP_ID, EMP_NAME 이름, SALARY, DEPT_CODE
FROM EMPLOYEE
-- ORDER BY EMP_ID ;  	-> 컬럼
-- ORDER BY 이름 DESC; 	-> 별칭
-- ORDER BY 3 DESC;   	-> 순서
ORDER BY 4 DESC, EMP_NAME;
-- 정렬을 한 상태에서 한 번더 정렬을 할 수 있다.


-- GROUP BY --

-- 부서별 평균 급여

-- 전체 사원의 급여 평균
SELECT TRUNC(AVG(SALARY), -3)
FROM EMPLOYEE;

-- D1의 평균
SELECT TRUNC(AVG(SALARY), -3)
FROM EMPLOYEE
WHERE DEPT_CODE = 'D1';

-- D6의 평균
SELECT TRUNC(AVG(SALARY), -3)
FROM EMPLOYEE
WHERE DEPT_CODE = 'D6';


-- GROUP BY 절 --
-- 특정 컬럼, 계산식을 기준으로
-- 그룹별로 묶어 한테이블 내에서 소그룹별로 조회하고자 할때 선언하는 구문


SELECT DEPT_CODE, TRUNC(AVG(SALARY), -3)
FROM EMPLOYEE
GROUP BY  DEPT_CODE;
-- 원래는 결과값의 ROW 개수가 맞지 않아 전체 평균과 DEPT_CODE를 같이 쓸수 없지만
-- 그룹으로 적절이 묶어 사용하여 해결


-- 부서 별 총인원, 급여 합계, 급여 평균, 최대 급여, 최소 급여를 조회
-- 단, 부서코드 기준으로 오름차순
-- 급여평균은 100의 자리까지만 처리하고 나머지는 버림처리하여 확인
SELECT DEPT_CODE, 
       COUNT(*), 
       SUM(SALARY), 
       TRUNC(AVG(SALARY), -3), 
       MAX(SALARY), 
       MIN(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_CODE
ORDER BY 1;


-- 직급 코드별 보너스받는 사원의 수 조회
SELECT JOB_CODE, COUNT(BONUS)
FROM EMPLOYEE
GROUP BY JOB_CODE
ORDER BY 1;


-- GROUP BY에서 주어진 컬럼 뿐만이 아니라 함수식도 사용 가능
SELECT DECODE(SUBSTR(EMP_NO, 8, 1), 2, '여성', '남성 '), COUNT(*)
FROM EMPLOYEE
GROUP BY SUBSTR(EMP_NO, 8, 1);


-- 부서별 급여 평균을 구해서 조회
-- 단, 부서별 급여 평균이 300만원 이상인 부서만 조회
SELECT DEPT_CODE, AVG(SALARY) 평균
FROM EMPLOYEE
WHERE SALARY > 3000000
GROUP BY DEPT_CODE;


-- HAVING: GROUP BY한 각 소그룹에 대한 조건을 설정
SELECT DEPT_CODE, AVG(SALARY) 평균
FROM EMPLOYEE
GROUP BY DEPT_CODE
HAVING AVG(SALARY) > 3000000;


-- 부서별 그룹의 급여 합계 중 900만원 초과하는 부서의
-- 코드와 급여합을 조회
SELECT DEPT_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_CODE 
HAVING SUM(SALARY) > 9000000;


-- 1) 급여 합계가 가장 높은 부서를 찾고,
-- 2) 해당 부서의 부서코드와 급여합계를 조회

-- 1) 급여 합이 가장 높은 부서의 급여 합 탐색
SELECT MAX(SUM(SALARY))
FROM EMPLOYEE
GROUP BY DEPT_CODE; 
-- 17,700,000

-- 2) 해당 부서의 부서코드와 급여합계를 조회
SELECT DEPT_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_CODE
HAVING SUM(SALARY) = 17700000;


-- Sub Query --
-- 1)과 2)의 코드를 하나로 합친 것!
SELECT DEPT_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_CODE
HAVING SUM(SALARY) = (SELECT MAX(SUM(SALARY))
                      FROM EMPLOYEE
                      GROUP BY DEPT_CODE);


-- 그룹으로 한번 묶고 묶인 그룹 안에서 한번더 그룹으로 나누어질 수 있다.
SELECT DEPT_CODE, JOB_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_CODE, JOB_CODE 
ORDER BY 1;


-- 집계함수 --
-- ROLLUP: 특정 그룹으로 묶은 뒤 해당 그룹에 대한 집계(총 합계)를 산출하는 함수
SELECT DEPT_CODE, JOB_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY ROLLUP(DEPT_CODE, JOB_CODE) 
ORDER BY 1, 2;


-- SET OPERATOR
-- 두개 이상의 SELECT 한 결과를
-- 합치거나, 합칠때 중복을 제거와 같은 
-- 집합 형태의 결과로 조회하는 명령어

-- SET OPERATOR는 아래로 늘어난다.
-- JOIN은 옆으로 늘어난다.


-- 합집합
-- UNION: 두개 이상의 SELECT한 결과(ResultSet)를 구하는 명령어
--        만약 중복이 있을 경우 중복되는 결과는 1번만 보여준다.          

SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
UNION
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE 
WHERE SALARY > 3000000;

-- UNION ALL: UNION과 동일. 단, 중복이 있어도 그대로 조회.
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
UNION ALL
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE 
WHERE SALARY > 3000000;


-- 교집합
-- INTERSECT: 중복되는 결과만 보여준다.
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
INTERSECT
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE 
WHERE SALARY > 3000000;


-- 차집합
-- MINUS: 가장 첫 결과에서 나머지 결과들과 일치하는 내용을 뺀 고유 결과를 조회
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
MINUS
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE 
WHERE SALARY > 3000000;


-- **[JOIN]** --
-- 두 개 이상의 테이블을 하나로 합쳐 조회하는데 사용하는 명령 구문

-- 'J6'라는 직급을 가진 사원들의 근무 부서명이 궁금하다...
-- 근무 부서명이 궁금하다...
SELECT EMP_NAME, JOB_CODE, DEPT_CODE
FROM EMPLOYEE
WHERE JOB_CODE = 'J6';

SELECT * FROM DEPARTMENT
WHERE DEPT_ID IN('D1', 'D8');


-- 오라클 전용 문법
-- FROM 절에 ,로 구분하며 합치게 될 테이블을 나열
-- 테이블을 엮는 기준으로 WHERE 조건을 명시한다.
SELECT EMP_NAME, JOB_CODE, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE, DEPARTMENT
WHERE DEPT_CODE = DEPT_ID;

-- 표준 문법
-- FROM 다음에 JOIN 테이블명 ON(조건식) || USING() 구문 사용
SELECT EMP_NAME, JOB_CODE, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE
JOIN DEPARTMENT ON(EMPLOYEE.DEPT_CODE = DEPARTMENT.DEPT_ID);


-- 두 개의 테이블에서 공통 컬럼의 이름이 같은 경우
-- 공통적인 컬럼이 존재하지 않는다면 합칠 수 없다.(물리적으로 합칠 수는 있지만 선호x)
-- EMPLOYEE테이블과 JOB테이블 JOIN
SELECT * FROM EMPLOYEE;
SELECT * FROM JOB;

-- 오라클 문법
SELECT EMP_ID, EMP_NAME, EMPLOYEE.JOB_CODE, JOB_NAME
FROM EMPLOYEE, JOB
WHERE EMPLOYEE.JOB_CODE = JOB.JOB_CODE;

SELECT EMP_ID, EMP_NAME, E.JOB_CODE, JOB_NAME
FROM EMPLOYEE E, JOB J
WHERE E.JOB_CODE = J.JOB_CODE;


-- 표준 문법
SELECT EMP_ID, EMP_NAME, JOB.JOB_CODE, JOB_NAME
FROM EMPLOYEE
JOIN JOB ON (EMPLOYEE.JOB_CODE = JOB.JOB_CODE);

SELECT EMP_ID, EMP_NAME, J.JOB_CODE, JOB_NAME
FROM EMPLOYEE E
JOIN JOB J ON (E.JOB_CODE = J.JOB_CODE);

SELECT EMP_ID, EMP_NAME, JOB_CODE, JOB_NAME
FROM EMPLOYEE
JOIN JOB USING(JOB_CODE);


-- 사번, 사원명, 급여 등급(SAL_GRADE), 등급 기준 최소급여, 최대급여 조회
-- EMPLOYEE테이블
-- SAL_GRADE테이블

-- 두 테이블 정보 조회(공통컬럼)
SELECT * FROM EMPLOYEE;
SELECT * FROM SAL_GRADE;

-- 표준 문법
SELECT EMP_ID, EMP_NAME, SAL_LEVEL, MIN_SAL, MAX_SAL
FROM EMPLOYEE
JOIN SAL_GRADE USING(SAL_LEVEL);


-- DEPARTMENT의 위치 정보와
-- LOCATION을 조인하여
-- 각 부서별 근무지 위치를 조회.
-- 부서코드, 부서명, 근무지코드, 근무지 위치

SELECT * FROM DEPARTMENT; -- LOCATION_ID
SELECT * FROM LOCATION;   -- LOCAL_CODE

SELECT DEPT_ID, DEPT_TITLE, LOCATION_ID, LOCAL_NAME
FROM DEPARTMENT
JOIN LOCATION ON (LOCATION_ID = LOCAL_CODE);


-- INNER JOIN / OUTER JOIN
-- INNER JOIN: 둘 모두 일치하는 데이터만 합친다.
-- OUTER JOIN: 둘 모두, 둘 중 하나가 가진 데이터 합친다.

-- INNER JOIN
SELECT DISTINCT DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID);

SELECT DISTINCT DEPT_CODE
FROM EMPLOYEE;

-- OUTER JOIN
-- LEFT JOIN: 두 테이블 중 원본(왼쪽) 테이블의 정보를 모두 포함하여 조회.
-- RIGHT JOIN: 두 테이블 중 JOIN에 명시한 테이블의 정보를 모두 포함하여 조회.
-- FULL JOIN: 두 테이블이 가진 데이터 중 서로가 가지지 않은 값일지라도 모두 포함하여 조회.


-- INNER JOIN
SELECT DEPT_CODE, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID);


-- LEFT JOIN
SELECT DEPT_CODE, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE
LEFT JOIN DEPARTMENT ON (DEPT_ID = DEPT_CODE);

-- 오라클 문법으로 표시
SELECT DEPT_CODE, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE, DEPARTMENT
WHERE DEPT_CODE = DEPT_ID(+);


-- RIGHT JOIN
SELECT DEPT_CODE, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE
RIGHT JOIN DEPARTMENT ON (DEPT_ID = DEPT_CODE);

-- 오라클 문법으로 표시
SELECT DEPT_CODE, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE, DEPARTMENT
WHERE DEPT_CODE(+) = DEPT_ID;


-- FULL JOIN
SELECT DEPT_CODE, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE
FULL JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID);

-- Oracle 구문에서는 FULL OUTER JOIN 지원안한다.
SELECT DEPT_CODE, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE, DEPARTMENT
WHERE DEPT_CODE(+) = DEPT_ID(+);


-- 추가적인 종류의 JOIN
-- 기본적인 JOIN은 양 테이블 정보에서 하나씩은 일치하는 정보를 가지고 JOIN 수행. EQ(EQUAL) JOIN
-- 하지만, 서로 같은 값을 가지지 않은 테이블의 정보를 조회 할 경우 CROSS JOIN을 통해 JOIN 수행가능

SELECT * FROM EMPLOYEE;
SELECT * FROM NATIONAL;

SELECT *
FROM EMPLOYEE
CROSS JOIN NATIONAL
ORDER BY 1;


-- NON-EQ JOIN
-- 특정 범위 내에 존재하는 조건으로 JOIN 수행

-- ON() 안에 계산식, 함수식 .. 다양하게 작성이 가능하다.
SELECT EMP_NAME, DEPT_CODE, SALARY, EMPLOYEE.SAL_LEVEL
FROM EMPLOYEE
JOIN SAL_GRADE ON (SALARY BETWEEN MIN_SAL AND MAX_SAL);


-- SELF JOIN
-- 자기 자신을 JOIN하는 방법.
-- 컬럼명이 다 똑같기 때문에 원본이랑 추가되는 컬럼을 구분해야한다.

-- 직원의 정보와 그 직원을 관리하는 매니저의 정보 조회
SELECT E.EMP_ID "사번",
	   E.EMP_NAME "사원명",
	   E.MANAGER_ID "관리자 사번",
	   M.EMP_NAME "관리자"
FROM EMPLOYEE E
JOIN EMPLOYEE M ON (E.MANAGER_ID = M.EMP_ID);
-- 원본 컬럼들과 JOIN 컬럼들의 별칭을 잘 구분해야한다.



-- 다중 JOIN
-- 여러개의 테이블을 JOIN
-- JOIN시 순서에 주의해서 작성해야 한다.

SELECT * 
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
JOIN LOCATION ON (LOCATION_ID = LOCAL_CODE);


SELECT EMP_NAME, DEPT_TITLE, LOCAL_NAME
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
JOIN LOCATION ON (LOCATION_ID = LOCAL_CODE);

-- ORACLE 구문
SELECT EMP_NAME, DEPT_TITLE, LOCAL_NAME
FROM EMPLOYEE, DEPARTMENT, LOCATION
WHERE DEPT_CODE = DEPT_ID 
  AND LOCATION_ID = LOCAL_CODE;

-- 문제1.
-- 한국(KO)과 일본(JP)에 근무하는 직원들의 정보 조회.
-- 사원명, 부서명, 지역명, 국가명
-- EMPLOYEE, NATIONAL, LOCATION, DEPARTMENT
SELECT EMP_NAME, DEPT_TITLE, LOCAL_NAME, NATIONAL_NAME
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
JOIN LOCATION ON (LOCATION_ID = LOCAL_CODE)
JOIN NATIONAL USING (NATIONAL_CODE)
WHERE NATIONAL_NAME IN ('한국', '일본');


-- 문제2.
-- 직급이 대리이면서, 아시아지역에서 근무하는 사원 조회
-- 사번, 사원명, 직급명, 부서명, 근무지역명, 급여
SELECT EMP_ID, EMP_NAME, JOB_NAME, DEPT_TITLE, LOCAL_NAME, SALARY
FROM EMPLOYEE
JOIN JOB USING (JOB_CODE)
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
JOIN LOCATION ON (LOCATION_ID = LOCAL_CODE)
WHERE JOB_NAME = '대리'
  AND LOCAL_NAME LIKE 'ASIA%';
  

--
SELECT EMP_ID, EMP_NAME, JOB_NAME, DEPT_TITLE, LOCAL_NAME, SALARY
FROM EMPLOYEE E
JOIN JOB J ON (E.JOB_CODE = J.JOB_CODE AND JOB_NAME = '대리')
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
JOIN LOCATION ON (LOCATION_ID = LOCAL_CODE AND LOCAL_NAME LIKE 'ASIA%');


-- ORACLE 구문
SELECT EMP_ID, EMP_NAME, JOB_NAME, DEPT_TITLE, LOCAL_NAME, SALARY
FROM EMPLOYEE E, JOB J, DEPARTMENT D, LOCATION L
WHERE E.JOB_CODE = J.JOB_CODE
  AND DEPT_CODE = DEPT_ID 
  AND LOCATION_ID = LOCAL_CODE 
  AND JOB_NAME = '대리'
  AND LOCAL_NAME LIKE 'ASIA%';


















